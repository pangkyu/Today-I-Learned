## 모던 자바스크립트 1주차

범위 : Part 1 1.1~1.6

---

### ch4 : array

> 개발을 진행하다보면 순서가 있는 컬렉션이 필요할 때가 생긴다. 이때 배열을 사용하면 된다.

- 객체는 순서를 고려하지 않고 만ㄷ르어진 자료구조이기 때문에 새로운 프로퍼티를 기존 프로퍼티 사이에 끼워 넣는 것이 불가능하다.

#### 배열 선언

```js
let arr = new Array();
let arr = [];

// 대부분 2번째 방법을 사용하는데, 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.
let fruits = ["사과", "오렌지", "자두"];
// 각 배열 요소에는 0부터 인덱스가 매개져 있다.
```

- 다음과 같은 방법으로 요소를 수정할 수 있다.

```js
fruits[2] = "배"; // 배열이 ["사과", "오렌지", "배"]로 바뀜
```

- 새로운 요소를 추가하는 것도 가능하다

```js
fruits[3] = "레몬"; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜
```

- 배열 요소의 자료형에는 제약이 없다.

```js
// 요소에 여러 가지 자료형이 섞여 있습니다.
let arr = [
  "사과",
  { name: "이보라" },
  true,
  function () {
    alert("안녕하세요.");
  },
];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다.
alert(arr[1].name); // 이보라

// 인덱스가 3인 요소(함수)를 실행합니다.
arr[3](); // 안녕하세요.
```

#### pop,push와 shift,unshift

- queue는 배열을 사용해 만들 수 있는 대표적인 자료구조, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용
- 선입선출(FIFO)자료구조
  - <code>push</code> : 맨 끝에 요소룰 추가
  - <code>shift</code> : 제일 앞 요소를 꺼내 제거한 후 남아있는 요소를 앞으로 밀어준다. 이렇게 하면 두번째 요소가 첫번째 요소가 된다.
- stack을 구현할 때도 사용된다.
- 후입선출(LIFO)자료구조
  - <code>push</code> : 요소를 스택 끝에 집어넣는다.
  - <code>pop</code> : 스택 끝 요소를 추출한다.

```JS
let fruits = ["사과", "오렌지", "배"];

alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert( fruits ); // 사과,오렌지

let fruits2 = ["사과", "오렌지"];

fruits2.push("배");

alert( fruits2 ); // 사과,오렌지,배
```

```js
let fruits = ["사과", "오렌지", "배"];

alert(fruits.shift()); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert(fruits); // 오렌지,배

let fruits2 = ["오렌지", "배"];

fruits2.unshift("사과");

alert(fruits2); // 사과,오렌지,배
```

- push와 unshift는 요소 여러개를 한번에 더해줄 수도 있다.

#### 배열의 내부 동작 원리

- 배열의 본질은 객체이다.
- 배열은 객체와 마찬가지로 참조를 통해 복사된다.

```js
let fruits = ["바나나"];

let arr = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)

alert(arr === fruits); // true

arr.push("배"); // 참조를 이용해 배열을 수정합니다.

alert(fruits); // 바나나,배 - 요소가 두 개가 되었습니다.
```

- 아래와 같이 사용하면 순서가 있는 자료의 컬렉션처럼 사용되지 않는다.
  - 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
  - <code>arr[0]</code>, <code>arr[100]</code>만 추가하고 그 사이에 아무런 요소가 없는 경우
  - <code>arr[100]</code>, <code>arr[99]</code> 같이 요소를 역순으로 채우는 경우

```js
let fruits = []; // 빈 배열을 하나 만듭니다.

fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만듭니다.

fruits.age = 25; // 임의의 이름을 사용해 프로퍼티를 만듭니다.
```

- 임의의 키를 사용해야 한다면 배열보다는 일반 객체 {}가 적합한 자료구조일 확률이 높다.

#### 성능

- push와 pop은 빠르지만 shift와 unshift는 느리다
- shift 연산은 아래 3가지 동작을 모두 사행해야 한다.

  1. 인덱스가 0인 요소를 제거
  2. 모든 요소를 왼쪽으로 이동시킨다
  3. length 프로퍼티 값을 갱신한다.

- 하지만, 배열에 요소가 많으면 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아진다.

#### 반복문

```js
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert(arr[i]);
}
```

- 배열에 적용할 수 있는 또 다른 순회 문법으로는 for..of가 있다.

```js
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행합니다.
for (let fruit of fruits) {
  alert(fruit);
}
```

- <code>for..of</code>를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다.
- 배열은 객체형에 속하므로<code>for in</code>를 사용하는 것도 가능하다.

```js
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert(arr[key]); // 사과, 오렌지, 배
}
```

- 하지만 for.. in은 다음과 같은 특징이 있기때문에, 다른 반복문을 사용하는 것이 좋다.
  1. <code>for..in</code>반복문은 모든 프로퍼티를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.
  2. <code>for..in</code>반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것보다 느리다.

#### length 프로퍼티

- 배열에 무언가 조작을 가하면 length 프로퍼티가 자동으로 갱신된다.
- 쓰기가 가능하다
- length의 값을 수동으로 증가시키면 아무 일도 일어나지 않는다. 그런데 값을 감소시키면 배열이 잘린다. 짧아진 배열은 다시 되돌릴 수 없다.

```js
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 잘라봅시다.
alert(arr); // [1, 2]

arr.length = 5; // 본래 길이로 되돌려 봅시다.
alert(arr[3]); // undefined: 삭제된 기존 요소들이 복구되지 않습니다.
```

#### new Array()

```js
let arr = new Array("사과", "배", "기타");
```

- 대괄호를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에 new Array()는 잘 사용되지 않는 편이다.

```js
let arr = new Array(2); // 이렇게 하면 배열 [2]가 만들어질까요?

alert(arr[0]); // undefined가 출력됩니다. 요소가 하나도 없는 배열이 만들어졌네요.

alert(arr.length); // 길이는 2입니다.
```

#### 다차원 배열

- 다차원 배열은 행렬을 저장하는 용도로 쓰인다.

```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

alert(matrix[1][1]); // 5, 중심에 있는 요소
```

#### toString

```js
let arr = [1, 2, 3];

alert(arr); // 1,2,3
alert(String(arr) === "1,2,3"); // true
```

- 배열엔 Symbol.toPrimitive나 valueOf 메소드가 없다. 따라서 문자열로의 형 변환이 일어나 []는 빈 문자열, [1]은 문자열 '1'로 변환된다.

```js
alert([] + 1); // "1"
alert([1] + 1); // "11"
alert([1, 2] + 1); // "1,21"
```
