## 모던 자바스크립트 1주차

범위 : Part 1 1.1~1.6

---

### ch3 : 가비지 컬렉션

> 자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행

##### 기준

- 자바스크립트는 도달 가능성(reachability) 개념으로 메모리 관리를 수행한다
  - 도달가능성 : 어떻게든 접근하거나 사용할 수 있는 값을 의미. 도달 가능한 값은 메모리에서 삭제되지 않는다.
  - 예시 : 현재 함수의 지역 변수와 매개변수, 중첩 함수의 체인에 있는 함수에서 사용되는 변수/매개변수, 전역 변수 등을 루트(root)라고 부른다.
  - 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.
- 자바스크립트 엔진에서는 가바지 컬렉터가 끊임없이 동작한다. 가비지 컬렉터는 모든 객체를 모니터링하고, 도달할 수 없는 객체는 삭제한다.

##### 예시

```js
let user = {
  name: "John",
};
```

- 전역변수 user는 <code>{name : 'John'}</code>를 참조한다.
- <code>user</code>의 값을 다른 값으로 덮어쓰면 참조가 사라진다.

```js
user = null;
```

- 이제 John은 도달할 수 없는 상태다. John에 접근할 방법도, 참조하는 것도 모두 사라졌다.
- 가비지 컬렉터는 John에 저장된 데이터를 삭제하고, John을 메모리에서 삭제한다.

##### 참조 두 개

```js
let user = {
  name: "John",
};
//user에서 admin으로 복사
let admin = user;

// user의 값을 다른 값으로 덮어쓰기
user = null;
```

- <code>admin</code>으로 여전히 John에 접근할 수 있기 때문에 John은 메모리에서 삭제되지 않는다
- <code>admin</code>도 다른 값으로 덮어쓰면 John은 메모리에서 삭제될 수 있다.

##### 연결된 객체

```js
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman,
  };
}
let family = marry(
  {
    name: "John",
  },
  {
    name: "Ann",
  }
);
```

- <code>marry</code>는 매개변수로 받은 두 객체를 서로 참조하고, 두 객체를 포함한 새로운 객체를 반환한다.

```js
// 참조 두 개를 지우기
delete family.father;
delete family.mother.husband;
```

- 하나만 지웠다면 모든 객체가 여전히 도달 가능한 상태지만, 모두 지워서 John으로 들어오는 참조가 사라졌다.
  - John은 도달 가능한 상태에서 벗어나짐
  - John은 메모리에서 제거되며, John에 저장된 데이터(프로퍼티)도 메모리에서 사라진다.
- 외부로 나가는 참조는 도달 가능한 상태에 영향을 주지 않는다.

```js
// family가 아무것도 참조하지 않을 경우
family = null;
```

- John과 Ann이 서로를 참조하고 있고, 두 객체 모두 외부에서 들어오는 참조를 가지지만, <code>family</code>객체와 루트의 연결이 사라지면 루트 객체를 참조하는 것이 아무것도 없다. 따라서 객체 전부가 메모리에서 제거된다.

##### 내부 알고리즘

- 'mark-and-sweep'은 가비지 컬렉션의 기본 알고리즘이다.
- 가비지 컬렉션의 단계
  - 가비지 컬렉터는 루트(root)정보를 수집하고 이를 mark(기억)한다.
  - 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark한다
  - mark된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark한다. 한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없다.
  - 루트에서 도달 가능한 모든 객체를 방문할 때 까지 위 과정을 반복한다.
  - mark되지 않은 모든 객체를 메모리에서 삭제한다.
- 루트에서 페인트를 붓는다고 생각하면 과정을 이해하기 쉬움(페인트가 묻지 않는 객체는 메모리에서 삭제)

- 최적화 기법
  - generational collection(세대별 수집)
    - 객체를 '새로운 객체'와 '오래된 객체'로 나눈다.
    - 객체 상당수는 생성 이후 자기 역할을 수행한 뒤, 쓸모가 없어지는데 이를 '새로운 객체'로 구분한다
    - 가바지 컬렉터는 새로운 객체를 공격적으로 메모리에서 제거한다.
    - 일정 시간 이상 동안 살아남은 객체는 '오래된 객체'로 분류하고, 가비지 컬렉터가 덜 감시한다.
  - incremental collection(점진적 수집)
    - 방문해야 할 객체가 많으면 모든 객체를 한 번에 방문하고 mark 하는데 오랜 시간이 걸린다.
    - 가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 느려진다.
    - 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리하여 각 부분을 별도로 수행한다.
    - 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있다.
  - idle-time collection(유휴 시간 수집)
    - 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때만 가비지 컬렉션을 실행한다.
- 이 외에도 다양한 최적화 기법과 가비지 컬렉션 알고리즘이 있다.
